(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{505:function(s,n,t){s.exports=t.p+"assets/img/image_20231209153427761.4f570b19.png"},506:function(s,n,t){s.exports=t.p+"assets/img/image_20231209200722288.cba2aef7.png"},507:function(s,n,t){s.exports=t.p+"assets/img/image_20231209201422592.dfa6b628.png"},508:function(s,n,t){s.exports=t.p+"assets/img/image_20231209185330775.aa5d4c33.png"},509:function(s,n,t){s.exports=t.p+"assets/img/image_20231209212640017.171489fe.png"},510:function(s,n,t){s.exports=t.p+"assets/img/image_20231209213237804.aaed6bcf.png"},511:function(s,n,t){s.exports=t.p+"assets/img/image_20231209214200577.eceb6093.png"},512:function(s,n,t){s.exports=t.p+"assets/img/image_20231209214445656.7592d4ff.png"},513:function(s,n,t){s.exports=t.p+"assets/img/image_20231216150812897.a77c5ad2.png"},514:function(s,n,t){s.exports=t.p+"assets/img/image_20231216150908142.6b140792.png"},515:function(s,n,t){s.exports=t.p+"assets/img/image_20231216151016579.8d6ffa83.png"},516:function(s,n,t){s.exports=t.p+"assets/img/image_20231216151120504.bb9dacf1.png"},517:function(s,n,t){s.exports=t.p+"assets/img/image_20231216151218976.9197104d.png"},518:function(s,n,t){s.exports=t.p+"assets/img/image_20231216151301386.210b596b.png"},519:function(s,n,t){s.exports=t.p+"assets/img/image_20231216151332135.e81f893d.png"},520:function(s,n,t){s.exports=t.p+"assets/img/image_20231216151406629.a84ffde0.png"},521:function(s,n,t){s.exports=t.p+"assets/img/image_20231210201214724.eb6b46ed.png"},522:function(s,n,t){s.exports=t.p+"assets/img/image_20231210201512060.b8cb440e.png"},523:function(s,n,t){s.exports=t.p+"assets/img/image_20231210203640735.c0e38971.png"},644:function(s,n,t){"use strict";t.r(n);var a=t(2),e=Object(a.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"六、树和二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#六、树和二叉树"}},[s._v("#")]),s._v(" 六、树和二叉树")]),s._v(" "),n("h2",{attrs:{id:"树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#树"}},[s._v("#")]),s._v(" 树")]),s._v(" "),n("h3",{attrs:{id:"树的定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#树的定义"}},[s._v("#")]),s._v(" 树的定义")]),s._v(" "),n("p",[s._v("有n(n≥0)个结点的有限集合。当n=0时，称为空树；任意一颗非空树应满足以下条件：")]),s._v(" "),n("p",[s._v("​\t1)、有且只有 一个根结点")]),s._v(" "),n("p",[s._v("​\t2)、当n>1时，除根结点外的其余结点被分成m(m>0)个互不相交的有线集合T1，T2,...,Tm,其中每个集合又是一棵树，并称为这个根结点的子树")]),s._v(" "),n("h3",{attrs:{id:"树的相关术语"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#树的相关术语"}},[s._v("#")]),s._v(" 树的相关术语")]),s._v(" "),n("p",[s._v("*"),n("em",[s._v("("),n("em",[s._v("下列此相关术语解释以下图做参考)")])])]),s._v(" "),n("img",{staticStyle:{zoom:"50%"},attrs:{src:t(505),alt:"image_20231209153427761"}}),s._v(" "),n("ul",[n("li",[n("p",[s._v("结点的度：结点所拥有的子树的个数。例：D有三个子树，即D结点的度为3；")])]),s._v(" "),n("li",[n("p",[s._v("树的度：树中所有结点的度的最大值。上图树的度为3.因为所有结点中最大的度为3；")])]),s._v(" "),n("li",[n("p",[s._v("祖先结点：往上知道根结点，做经过的所有结点都称为祖先结点。例：E的祖先结点有B、A；")])]),s._v(" "),n("li",[n("p",[s._v("子孙结点：一个结点的所有分支。例：B的子孙结点有K、L、E、F；")])]),s._v(" "),n("li",[n("p",[s._v("双亲结点/父结点：往上一级结点。例：E的双亲结点为B；")])]),s._v(" "),n("li",[n("p",[s._v("孩子结点：往下一级结点。例：B的孩子结点有E、F；(*孩子结点只包括往下一级，而子孙结点包括往下的所有)")])]),s._v(" "),n("li",[n("p",[s._v("兄弟结点：同一个前驱结点。例：E、F都是由B分出来的，即E、F为兄弟结点；")])]),s._v(" "),n("li",[n("p",[s._v("堂兄弟结点：处于同一级且不是同一个前驱结点。例：E、G的前驱结点不是同一个，即E、G为堂兄弟结点；")])]),s._v(" "),n("li",[n("p",[s._v("路径：从根结点A开始到结点E，路径为A->B->E,其路径长度就是有几条边，A到E的路径长度为2；")])]),s._v(" "),n("li",[n("p",[s._v("有序树&无序树：从逻辑上看，有序树中结点的各子树从左至右是有次序的，不可互换；而无序树中结点的各子树从左至右是无次序的，可以互换；")])])]),s._v(" "),n("h3",{attrs:{id:"树的基本性质"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#树的基本性质"}},[s._v("#")]),s._v(" 树的基本性质")]),s._v(" "),n("p",[s._v("​\t1)、树中的结点数等于所有结点的度数之和加一；(*加一是因为每个结点有且仅有一个前驱结点，才构成度，但是根结点是没有前驱结点的，加一即加上跟结点)")]),s._v(" "),n("p",[s._v("​\t2)、度为m的树中第i层上最多有m^(i-1)个结点（i≥1）")]),s._v(" "),n("p",[s._v("​\t3)、高度为h的m叉树最多有m^(h)-1/m-1个结点")]),s._v(" "),n("p",[s._v("​\t4)、具有n个结点的m叉树的最小高度是：log( n(m-1) + 1)以m为底；")]),s._v(" "),n("h3",{attrs:{id:"树的基本运算"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#树的基本运算"}},[s._v("#")]),s._v(" 树的基本运算")]),s._v(" "),n("h4",{attrs:{id:"先根遍历-根左右"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#先根遍历-根左右"}},[s._v("#")]),s._v(" 先根遍历(根左右)")]),s._v(" "),n("p",[s._v("①先访问根节点。②按照从左到右的顺序先遍历根结点的每一颗子树。按照上图的先根遍历结果为：ABEKLFCGDHMIJ")]),s._v(" "),n("h4",{attrs:{id:"后根遍历-左右根"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#后根遍历-左右根"}},[s._v("#")]),s._v(" 后根遍历(左右根)")]),s._v(" "),n("p",[s._v("①按照从左到右的顺序先遍历根结点的每一颗子树。②访问根结点。按照上图的后根遍历结果：KLEFBGCMHIJDA")]),s._v(" "),n("h4",{attrs:{id:"层次遍历"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#层次遍历"}},[s._v("#")]),s._v(" 层次遍历")]),s._v(" "),n("p",[s._v("即头结点开始依次从上往下从左往右的顺序访问每一个结点。按照上图层次遍历的结果：ABCDEFGHIJKLM")]),s._v(" "),n("h3",{attrs:{id:"树的存储结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#树的存储结构"}},[s._v("#")]),s._v(" 树的存储结构")]),s._v(" "),n("h4",{attrs:{id:"双亲表示法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#双亲表示法"}},[s._v("#")]),s._v(" 双亲表示法")]),s._v(" "),n("p",[s._v("​\t是一种顺序存储结构，用一组连续的空间来存储树中的结点，在保存每个结点的同时附设一个指示器parent指示其双亲结点在表中的位置。")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("typedef struct\n{\n\tElemtype data; //存放节点数据\n\tint parent;//存放双亲的位置\n}PTree[MaxSize];\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("img",{staticStyle:{zoom:"40%"},attrs:{src:t(506),alt:"image_20231209200722288"}}),s._v(" "),n("h4",{attrs:{id:"孩子表示法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#孩子表示法"}},[s._v("#")]),s._v(" 孩子表示法")]),s._v(" "),n("p",[s._v("​\t用一组连续的空间来存储树中的结点，把每个结点的孩子在表中的位置（并非孩子本身）排列起来构成一个单链表，称为孩子链表。n个结点共有n个孩子链表。")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("typedef struct node{\n\tElemType data;//结点的值\n\tstruct node * sons[MaxSons];//指向孩子结点\n}TSonNode;\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("img",{staticStyle:{zoom:"40%"},attrs:{src:t(507),alt:"image_20231209201422592"}}),s._v(" "),n("h2",{attrs:{id:"二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[s._v("#")]),s._v(" 二叉树")]),s._v(" "),n("h3",{attrs:{id:"定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[s._v("#")]),s._v(" 定义")]),s._v(" "),n("p",[s._v("​\t\t有限的结点的集合，由根结点和不相交的二叉子树组成；")]),s._v(" "),n("p",[s._v("​\t\t二叉树的五种基本形态：")]),s._v(" "),n("img",{staticStyle:{zoom:"50%"},attrs:{src:t(508),alt:"image_20231209185330775"}}),s._v(" "),n("h3",{attrs:{id:"树和二叉树的联系与区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#树和二叉树的联系与区别"}},[s._v("#")]),s._v(" 树和二叉树的联系与区别")]),s._v(" "),n("p",[s._v("​\t满足以下两个条件的树形结构叫做二叉树：")]),s._v(" "),n("ul",[n("li",[s._v("每个结点至多只有两棵子树")]),s._v(" "),n("li",[s._v("二叉树的子树有左右之分，其次序不能颠倒，是有序树。而树可以有序可以无序")])]),s._v(" "),n("p",[s._v("【孩子与双亲：结点若有直接后继，则可称它为它直接后继结点的父亲或双亲，直接后继结点为它的孩子，位于左边的孩子叫做左孩子，位于右边的孩子叫做右孩子】")]),s._v(" "),n("h3",{attrs:{id:"二叉树的基本术语"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的基本术语"}},[s._v("#")]),s._v(" 二叉树的基本术语")]),s._v(" "),n("ul",[n("li",[s._v("结点的度：结点直接后继的个数")]),s._v(" "),n("li",[s._v("树的度：树的所有结点的度的最大值")]),s._v(" "),n("li",[s._v("叶子结点：也称终端结点，即度为0的结点")]),s._v(" "),n("li",[s._v("分支结点：也称非终端结点，即度不为0的结点")]),s._v(" "),n("li",[s._v("孩子结点：结点的直接后继")]),s._v(" "),n("li",[s._v("双亲结点：结点的直接前驱")]),s._v(" "),n("li",[s._v("兄弟结点：同一双亲结点的孩子结点互称兄弟结点")])]),s._v(" "),n("h3",{attrs:{id:"二叉树的分类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的分类"}},[s._v("#")]),s._v(" 二叉树的分类")]),s._v(" "),n("h4",{attrs:{id:"满二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#满二叉树"}},[s._v("#")]),s._v(" 满二叉树")]),s._v(" "),n("p",[s._v("一颗高度为h，且含有2^h-1结点的二叉树。(人话：除了根结点外，其余分支结点都有两个度，不存在只有一个度的结点)如下图：")]),s._v(" "),n("img",{staticStyle:{zoom:"40%"},attrs:{src:t(509),alt:"image_20231209212640017"}}),s._v(" "),n("p",[s._v("**特点：**①不存在度为1的结点")]),s._v(" "),n("p",[s._v("​\t\t\t②只有最后一层有叶子节点")]),s._v(" "),n("p",[s._v("​\t\t\t③按层序从1开始编号，结点为i的左孩子为2i，右孩子为2i+1，结点i的父结点为i/2(如果有的话)")]),s._v(" "),n("h4",{attrs:{id:"完全二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#完全二叉树"}},[s._v("#")]),s._v(" 完全二叉树")]),s._v(" "),n("p",[s._v("当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树")]),s._v(" "),n("img",{staticStyle:{zoom:"40%"},attrs:{src:t(510),alt:"image_20231209213237804"}}),s._v(" "),n("p",[s._v("**特点：**①只有最后两层可能有叶子结点\n②最多只有一个度为1的结点\n③按层序从1开始编号，结点为i的左孩子为2i，右孩子为2i+1，结点i的父结点为i/2(如果有的话)\n④i≤n/2为分支结点，i>n/2为叶子结点")]),s._v(" "),n("p",[s._v("​\t\t\t(补充：1.对于完全二叉树，如果只有一个子结点时，那么一定是左结点")]),s._v(" "),n("p",[s._v("​\t\t\t\t\t\t2.满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树)")]),s._v(" "),n("h4",{attrs:{id:"二叉排序树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉排序树"}},[s._v("#")]),s._v(" 二叉排序树")]),s._v(" "),n("p",[s._v("一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树:")]),s._v(" "),n("ul",[n("li",[s._v("​\t左子树上所有结点的关键字均小于根结点的关键字;")]),s._v(" "),n("li",[s._v("​\t右子树上所有结点的关键字均大于根结点的关键字。")]),s._v(" "),n("li",[s._v("​\t且左子树和右子树又各是一颗二叉排序树 。")])]),s._v(" "),n("img",{staticStyle:{zoom:"40%"},attrs:{src:t(511),alt:"image_20231209214200577"}}),s._v(" "),n("h4",{attrs:{id:"平衡二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#平衡二叉树"}},[s._v("#")]),s._v(" 平衡二叉树")]),s._v(" "),n("p",[s._v("树上任意结点的左子树与右子树的深度之差不超过1")]),s._v(" "),n("img",{staticStyle:{zoom:"40%"},attrs:{src:t(512),alt:"image_20231209214445656"}}),s._v(" "),n("h3",{attrs:{id:"二叉树的存储结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的存储结构"}},[s._v("#")]),s._v(" 二叉树的存储结构")]),s._v(" "),n("h4",{attrs:{id:"顺序存储"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#顺序存储"}},[s._v("#")]),s._v(" 顺序存储")]),s._v(" "),n("p",[s._v("顺序结构存储就是使用数组来存储，按编号顺序存储。")]),s._v(" "),n("p",[s._v("所以对于完全二叉树，直接从根起按层序存储即可，依次自上向下自左向右存储结点元素，将完全二叉树中编号为i的结点存储在数组中下标为i-1的分量中。而对于一般的二叉树，由于也是按照编号存储，二叉树的顺序存储中可能会出现大量未用分量，十分浪费空间所以对于一般二叉树，不适合用顺序存储，")]),s._v(" "),n("p",[s._v("由此可见二叉树的顺序存储只适合完全二叉树的存储。对于一般二叉树，更适合二叉树的链式存储。二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。")]),s._v(" "),n("img",{staticStyle:{zoom:"43%"},attrs:{src:t(513),alt:"image_20231216150812897"}}),s._v(" "),n("h4",{attrs:{id:"链式存储"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#链式存储"}},[s._v("#")]),s._v(" 链式存储")]),s._v(" "),n("p",[s._v("二叉树由根节点和左右子树构成（如a图）。所以二叉树的结点由数据域，左右指针域，三个部分构成（如图b）。为了便于寻找结点的双亲，我们可以增加一个指向双亲结点的指针域。（如图c）")]),s._v(" "),n("img",{staticStyle:{zoom:"33%"},attrs:{src:t(514),alt:"image_20231216150908142"}}),s._v(" "),n("p",[s._v("利用这两种结点，所得到的二叉树的存储结构分别称为二叉链表和三叉链表：")]),s._v(" "),n("img",{staticStyle:{zoom:"50%"},attrs:{src:t(515),alt:"image_20231216151016579"}}),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("typedef int BTDataType;\n// 二叉链\nstruct BinaryTreeNode\n{\n\tstruct BinTreeNode* _pLeft; // 指向当前节点左孩子\n\tstruct BinTreeNode* _pRight; // 指向当前节点右孩子\n\tBTDataType _data; // 当前节点值域\n}\n\n// 三叉链\nstruct BinaryTreeNode\n{\n    struct BinTreeNode* _pParent; // 指向当前节点的双亲\n    struct BinTreeNode* _pLeft; // 指向当前节点左孩子\n    struct BinTreeNode* _pRight; // 指向当前节点右孩子\n    BTDataType _data; // 当前节点值域\n}；\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br")])]),n("h3",{attrs:{id:"二叉树的遍历"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的遍历"}},[s._v("#")]),s._v(" 二叉树的遍历")]),s._v(" "),n("p",[s._v("按照一定的次序访问二叉树中的所有结点，并且每个 结点仅被访问一次的过程。分别用LDR表示二叉树的根节点，左子树，右子树。我们就有3！种遍历顺序，若规定先左后右，就只有三种：DLR、LDR、LRD，分别对应先序遍历、中序遍历、后续遍历。")]),s._v(" "),n("h4",{attrs:{id:"先、中、后序遍历-递归"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#先、中、后序遍历-递归"}},[s._v("#")]),s._v(" 先、中、后序遍历（递归）")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('//先序——访问根结点的操作发生在遍历其左右子树之前。\nvoid PreOrder(BTNode *b)\n{  if (b!=NULL)  \n   {  printf("%c "，b->data); \t//访问根结点\n      PreOrder(b->lchild);\n      PreOrder(b->rchild);\n   }\n}\n\n//中序——访问左结点的操作发生在遍历其根结点和右子树之前。\nvoid InOrder(BTNode *b)\n{  if (b!=NULL)  \n   {  InOrder(b->lchild);\n      printf("%c "，b->data); \t//访问根结点\n      InOrder(b->rchild);\n   }\n}\n\n//后序——访问左右结点的操作发生在遍历其根结点之前。\nvoid PostOrder(BTNode *b) \n{  if (b!=NULL)  \n   {  PostOrder(b->lchild);\n      PostOrder(b->rchild);\n      printf("%c "，b->data); \t//访问根结点\n   }\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br")])]),n("p",[s._v("这里算法中的访问是直接输出结点值。实际上，访问结点可以对该结点进行各种操作，如计数、删除结点等。3种递归算法的执行过程是递归的。以先序遍历图解：")]),s._v(" "),n("img",{staticStyle:{zoom:"37%"},attrs:{src:t(516),alt:"image_20231216151120504"}}),s._v(" "),n("h4",{attrs:{id:"先、中、后序遍历-非递归"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#先、中、后序遍历-非递归"}},[s._v("#")]),s._v(" *先、中、后序遍历（非递归）")]),s._v(" "),n("p",[s._v("递归在系统中本质就是系统栈的使用，所以递归能遍历二叉树，那么就能使用栈堆二叉树进行非递归遍历。")]),s._v(" "),n("p",[s._v("算法思路：")]),s._v(" "),n("ol",[n("li",[n("p",[s._v("初始化空战，指针p指向根节点H")])]),s._v(" "),n("li",[n("p",[s._v("申请一个结点空间用来存放栈顶弹出去的元素")])]),s._v(" "),n("li",[n("p",[s._v("当p非空或栈非空，循环执行以下操作：")]),s._v(" "),n("p",[s._v("如果p非空，则p进栈，p指向该节点的左孩子")]),s._v(" "),n("p",[s._v("如果p为空，则弹出栈顶元素并访问根节点，将p指向该节点的有孩子")])]),s._v(" "),n("li",[n("p",[s._v("先序非递归遍历：")]),s._v(" "),n("p",[s._v("指针指向根节点，建立栈。循环遍历：")]),s._v(" "),n("p",[s._v("​\tp非空则入栈，同时p指向左子树")]),s._v(" "),n("p",[s._v("​\tp空则出栈顶元素，p指向栈顶的右子树")]),s._v(" "),n("p",[s._v("​\t先序遍历就是在入栈的时候输出")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//前序非递归遍历\nvoid PreOrderTraverse(BTNode* root){\n    \n\tif (root == NULL)\n\t\treturn;\n\tBTNode* p = root;\n\tstack<BTNode*> s;\n\twhile (!s.empty() || p)\n\t{\n\t\tif (p)\n\t\t{\n\t\t\tcout << setw(4) << p->data;\n\t\t\ts.push(p);\n\t\t\tp = p->lchild;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp = s.top();\n\t\t\ts.pop();\n\t\t\tp = p->rchild;\n\t\t}\n\t}\n\tcout << endl;\n}\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br")])])]),s._v(" "),n("li",[n("p",[s._v("中序非递归遍历：")]),s._v(" "),n("p",[s._v("​\tp非空则入栈，同时p指向左子树")]),s._v(" "),n("p",[s._v("​\tp空则出栈顶元素，p指向栈顶的右子树")]),s._v(" "),n("p",[s._v("​\t中序遍历就是在栈顶出元素的时候输出")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('//中序非递归遍历\nvoid InOrderTraverse(BTreeNode* root){\n    \n    if (root == NULL)\n\t\treturn;\n\tstack<BTreeNode*> s;\n\tBTreeNode* temp;\n\tBTreeNode* p = root;\n\twhile (p || !s.empty()){\n\t\tif (p) {\n\t\t\ts.push(p);\n\t\t\tp = p->left;\n\t\t}\n\t\telse {\n\t\t\ttemp = s.top();\n\t\t\ts.pop();\n\t\t\tcout << temp->data << "->";\n\t\t\tp = temp->right;\n\t\t}\n\t}\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br")])])]),s._v(" "),n("li",[n("p",[s._v("后序非递归遍历：")]),s._v(" "),n("p",[s._v("​\t后序遍历的难点在于：需要判断上次访问的节点是位于左子树，还是右子树。若是位于左子树，则需跳过根节点，先进入右子树，再回头访问根节点；若是位于右子树，则直接访问根节点。这里用到一个指针pLastVisit记录上次访问过的结点,节点能被访问的前提就是:无右子树或右子树已被访问过")])])]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('//后续非递归遍历\nvoid PostOrderTraverse(BTNode* root)\n{\n\tif (root == NULL)\n\t\treturn;\n\n\tBTNode* pcur = root;\n\tBTNode* pLastVisit = NULL;\n\t//pCur:当前访问节点，pLastVisit:上次访问节点\n\tstack<BTNode*>s;\n\n\t//先把pCur移动到左子树最下边\n\twhile (pcur) {\n\t\ts.push(pcur);\n\t\tpcur = pcur->left;\n\t}\n\n\twhile (!s.empty()) {\n\n\t\t//走到这里，pCur都是空，并已经遍历到左子树底端\n\t\tBTNode* pcur = s.top();\n\t\ts.pop();\n\n\t\t//一个根节点被访问的前提是：无右子树或右子树已被访问过\n\t\tif (pcur->right == NULL || pLastVisit == pcur->right) {\n\t\t\tcout << pcur->data << "->";\n\t\t\tpLastVisit = pcur;\n\t\t}\n\t\telse {\n\t\t\t//走到这根结点不配出栈，重新入栈\n\t\t\ts.push(pcur);\n\n\t\t\t//进入右子树，且可肯定右子树一定不为空\n\t\t\tpcur = pcur->right;\n\n\t\t\t//访问一个新结点，就遍历到左子树左下底\n\t\t\twhile(pcur) {\n\t\t\t\ts.push(pcur);\n\t\t\t\tpcur=pcur->left;\n\t\t\t}\n\t\t}\n\t}\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br")])]),n("h4",{attrs:{id:"层次遍历-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#层次遍历-2"}},[s._v("#")]),s._v(" 层次遍历")]),s._v(" "),n("p",[s._v("所谓层序遍历，就是自上而下，自左向右逐层访问的过程：")]),s._v(" "),n("img",{staticStyle:{zoom:"33%"},attrs:{src:t(517),alt:"image_20231216151218976"}}),s._v(" "),n("p",[s._v("层序遍历核心思路就是上一层带下一层，调用队列预先写好的函数辅助实现层序遍历。具体来说就是将结点自上到下逐层放入队列中，每次队列出一个节点，直到最后队列为空，遍历完成。代码如下：")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('void LevelOrder(BinaryTreeNode* root)\n{\n\tQueue BTree;//层序遍历的队列\n\tQueueInit(&BTree);//队列初始化\n\tif (root)QueuePush(&BTree,root);//入队\n\twhile (!QueueEmpty(&BTree))//队列空，循环终止\n\t{\n\t\tBinaryTreeNode* temp = QueueFront(&BTree);\n\t\tQueuePop(&BTree);\n\t\tcout << temp->data << " -> ";\n\t\tif (temp->left)QueuePush(&BTree, temp->left);//上一层带下一层\n\t\tif (temp->right)QueuePush(&BTree, temp->right);//上一层带下一层\n\t}\n\tcout << endl;\n\tQueueDestory(&BTree);//销毁队列\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br")])]),n("h3",{attrs:{id:"二叉树的构造"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的构造"}},[s._v("#")]),s._v(" 二叉树的构造")]),s._v(" "),n("h4",{attrs:{id:"先序序列构造二叉数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#先序序列构造二叉数"}},[s._v("#")]),s._v(" 先序序列构造二叉数")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//根据先序遍历序列创建二叉树\n//根据数值和传入指针构建结点\nvoid newNode(BinaryTreeNode*& newp,char data) {\n\tnewp = (BinaryTreeNode*)malloc(sizeof(BinaryTreeNode));\n\tnewp->data = data;\n\tnewp->left = NULL;\n\tnewp->right = NULL;\n}\n\n//构建二叉树，传进来的字符串：AB^DF^^^CEG^^H^^^，index初始值为0\nvoid createTree(BinaryTreeNode*& root,string prevStr,int& index) {\n\tif (prevStr[index] != '^'){\n\t\tnewNode(root, prevStr[index]);\n\t\tindex++;\n\t\tcreateTree(root->left, prevStr, index);\n\t\tcreateTree(root->right, prevStr, index);\n\t}\n\telse {\n\t\tindex++;\n\t\treturn;\n\t}\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br")])]),n("h4",{attrs:{id:"后续序列构建二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#后续序列构建二叉树"}},[s._v("#")]),s._v(" 后续序列构建二叉树")]),s._v(" "),n("p",[s._v("思想将后序序列倒过来，就是根-右节点-左结点，先构建右子树，再构建左子树，string下标也是倒着来")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//根据数值和传入指针构建结点\nvoid newNode(BinaryTreeNode*& newp,char data) {\n\tnewp = (BinaryTreeNode*)malloc(sizeof(BinaryTreeNode));\n\tnewp->data = data;\n\tnewp->left = NULL;\n\tnewp->right = NULL;\n}\n//构建二叉树，传进来的字符串：AB^DF^^^CEG^^H^^^,index初始值为postStr最大下标\nvoid createTree2(BinaryTreeNode*& root, string postStr, int& index) {\n\tif (postStr[index] != '^') {\n\t\tnewNode(root, postStr[index]);\n\t\tindex--;\n\t\tcreateTree2(root->right, postStr, index);//先构建右子树\n\t\tcreateTree2(root->left, postStr, index);\n\t}\n\telse {\n\t\tindex--;\n\t\treturn;\n\t}\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br")])]),n("h2",{attrs:{id:"线性二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线性二叉树"}},[s._v("#")]),s._v(" 线性二叉树")]),s._v(" "),n("h3",{attrs:{id:"基本定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基本定义"}},[s._v("#")]),s._v(" 基本定义")]),s._v(" "),n("p",[s._v("所谓线索二叉树就是将二叉链表中的空指针改为指向前趋和后继的线索。")]),s._v(" "),n("p",[s._v("对于n个结点的指针，就相应的有n+1的空指针域，线索二叉树就是将这些空指针域利用起来！")]),s._v(" "),n("p",[s._v("我们知道二叉树遍历次序有先序遍历，中序遍历，后序遍历，这三种遍历次序对应的输出结果分别对应先序序列，中序序列，后序序列。而线索二叉树中的前趋和后继就是指的序列中位置的前趋和后继！举例：对于如下二叉树")]),s._v(" "),n("img",{staticStyle:{zoom:"50%"},attrs:{src:t(518),alt:"image_20231216151301386"}}),s._v(" "),n("p",[s._v("其中序输出序列为：CBEGDFA，所以对于E结点其前趋为B，后继为G。")]),s._v(" "),n("p",[s._v("理解的前趋后继，下面谈谈如何将二叉树修改成线索二叉树！")]),s._v(" "),n("p",[s._v("如果结点左指针为空，就将该指针指向结点在序列中的前驱。如果结点右指针为空，就将该指针指向结点在序列中的后继。")]),s._v(" "),n("p",[s._v("为了弄清指针指向的时左右子树还是前驱后继，我们在结点中增加两个标志域LTag和RLag\n"),n("img",{staticStyle:{zoom:"50%"},attrs:{src:t(519),alt:"image_20231216151332135"}})]),s._v(" "),n("ul",[n("li",[s._v("这种结点结构的构成的二叉树叫线索二叉树")]),s._v(" "),n("li",[s._v("对应的存储结构叫做线索链表")]),s._v(" "),n("li",[s._v("结点中指向前驱后继的指针叫做线索。")])]),s._v(" "),n("p",[s._v("了解完线索二叉树的基本概念，来看个例子，看看其指针指向：如图（a）所示为中序线索二叉树，与其对应的中序线索链表如图（b）所示。")]),s._v(" "),n("p",[s._v("其中实线为指针(指向左、右子树)，虚线为线索(指向前驱和后继)。")]),s._v(" "),n("img",{staticStyle:{zoom:"50%"},attrs:{src:t(520),alt:"image_20231216151406629"}}),s._v(" "),n("p",[s._v("可以看出：线索二叉树仿照线性表的存储结构")]),s._v(" "),n("p",[s._v("在二叉树的线索链表上也添加一个头节点，并令其lchild域的指针指向二叉树的根节点，令其rchild域的指针指向中序遍历时访问的最后一个节点；")]),s._v(" "),n("p",[s._v("同时,令二叉树中序序列中第一个节点的lchild域指针和最后一个节点的rchild域指针均指向头节点。(中序序列第一个结点就是二叉树最左边的结点和最右边的结点)")]),s._v(" "),n("p",[s._v("这好比为二叉树建立了一个双向线索链表,既可从第一个节点起顺后继进行遍历，也可从最后一个节点起顺前驱进行遍历。")]),s._v(" "),n("h3",{attrs:{id:"构造线性二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构造线性二叉树"}},[s._v("#")]),s._v(" 构造线性二叉树")]),s._v(" "),n("p",[s._v("构造线索二叉树的过程就是将二叉链表中的空指针改为指向前趋和后继的线索的过程。也就是说二叉树线索化就是修改空指针的过程。")]),s._v(" "),n("p",[s._v("由于前趋和后继只有在遍历的时候才能获得，所以按照不同的遍历次序对二叉树线索化，可以得到分别得到先序线索二叉树，中序线索二叉树，后续线索二叉树。")]),s._v(" "),n("p",[s._v("在讲解构造线索二叉树前，相信二叉树的遍历大家都很清楚了，访问结点的先后顺序时不变的（框架不变）。所谓先中后遍历二叉树就是将输出语句放在不同的位置，如下：")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('void prevOrder(BinaryTreeNode* root)\n{\n\tif (root == NULL)\n\t{\n\t\tcout << "NULL->";\n\t\treturn;\n\t}\n\t//cout << root->data << "->";//放在此处就是先序遍历\n\tprevOrder(root->left);\n\t//cout << root->data << "->";//放在此处就是中序遍历\n\tprevOrder(root->right);\n\t//cout << root->data << "->";//放在此处就是后序遍历\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br")])]),n("p",[s._v("将修改空指针的操作和记录前趋节点的操作放在放在二叉树遍历的不同位置，就衍生出先序线索二叉树，中序线索二叉树，后续线索二叉树。")]),s._v(" "),n("p",[s._v("为了记下遍历过程中访问结点的先后关系，便于当前节点的线索化，左指针指向前前趋，右指针指向后继。"),n("em",[s._v("设置一个指针pre始终指向刚刚访问过的结点，而p指针指向当前结点")])]),s._v(" "),n("p",[s._v("我们每次修改空指针，都改变"),n("strong",[s._v("当前节点的左指针，改变前趋（也就是prev）的右指针")]),s._v("。这样再遍历过后除了，除了序列的最后一个节点的后继没有修改外，其余节点均被完全线索化了。来看看个图就明白了：\n"),n("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-2296.oss-cn-shenzhen.aliyuncs.com/image_20221109161606056.png",alt:"image_20221109161606056"}})]),s._v(" "),n("p",[s._v("记住："),n("strong",[s._v("当前节点的左指针，改变前趋（也就是prev）的右指针")])]),s._v(" "),n("p",[s._v("对于当前节点C而言，修改左指针，遍历一次后C成为前趋，修改前趋的右指针（C的后继），这样C的左右指针都做了修改。")]),s._v(" "),n("h4",{attrs:{id:"中序线索二叉树的构建"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#中序线索二叉树的构建"}},[s._v("#")]),s._v(" 中序线索二叉树的构建")]),s._v(" "),n("p",[s._v("在修改空指针前我们需要记下当前结点的前驱后继！所以"),n("strong",[s._v("设置一个指针"),n("code",[s._v("pre")]),s._v("v始终指向刚刚访问过的结点，而"),n("code",[s._v("p")]),s._v("指针指向当前结点")]),s._v("，在构造中序线索二叉树前，我们先理解pre指针和p指针时如何记录当前结点和前趋的，这样能更有利于我们理解中序二叉树的构建：")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//将以p为根的二叉树线索化的部分代码\nvoid InThreading(BTNode* p,BTNode*& prev) {\n\t//if (!root)return;//可以写但很多余\n\n\t//prev是全局定义好的变量，用于指向刚刚访问过的结点\n\tif (p) {\n\t\tInThreading(p->left,prev);\n\t\tprev = p;\n\t\tInThreading(p->right,prev);\n\t}\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br")])]),n("p",[s._v("可以看到，和遍历输出二叉链表的代码实现很像！p非空？那就递归左子树线索化，记录根结点"),n("code",[s._v("prev = p;")]),s._v("，再右子树线索化！")]),s._v(" "),n("p",[n("code",[s._v("prev")]),s._v("的初始值指向线索二叉树的头节点"),n("code",[s._v("Thrt")]),s._v("，对于中序第一个结点，它的前趋就是二叉搜索树的头节点")]),s._v(" "),n("p",[s._v("上面代码，每一层递归都记录下的当前结点和上一个结点：每一层递归中当前结点为p，当前结点的前趋为prev。下一步接着加入修改空指针的操作：")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//将以p为根的二叉树线索化\nvoid InThreading(BTNode* p, BTNode*& prev) {\n\t//if (!root)return;//可以写但很多余\n\n\t//prev是全局定义好的变量，用于指向刚刚访问过的结点\n\tif (p) {\n\n\t\tInThreading(p->left, prev);\n\n\t\tif (!p->left) {\n\t\t\tp->LTag = 1;//标记p->left为左线索\n\t\t\tp->left = prev;//指向前趋\n\t\t}\n\t\telse p->LTag = 0;//标记p->left指向左子树\n\n\t\tif (!prev->right) {\n\t\t\tprev->RTag = 1;//标记p->right为右线索\n\t\t\tprev->right = p;//指向后继\n\t\t}\n\t\telse prev->RTag = 0;//标记p->right指向右子树\n\n\t\tprev = p;\n\n\t\tInThreading(p->right, prev);\n\t}\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br")])]),n("p",[s._v("上面说过，我们每次修改空指针，都改变"),n("strong",[s._v("当前节点的左指针，改变前趋（也就是prev）的右指针")]),s._v("。这样再遍历过后除了，除了序列的最后一个节点的后继没有修改外，其余节点均被完全线索化了。所以真正的代码实现我们还需要对序列最后一个节点的后继线索化！，下面是完整的线索化二叉树实现：")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//将以p为根的二叉树线索化\nvoid InThreading(BTNode* p, BTNode*& prev) {\n\t//if (!root)return;//可以写但很多余\n\n\t//prev是全局定义好的变量，用于指向刚刚访问过的结点\n\tif (p) {\n\n\t\tInThreading(p->left, prev);\n\n\t\tif (!p->left) {\n\t\t\tp->LTag = 1;//标记p->left为左线索\n\t\t\tp->left = prev;//指向前趋\n\t\t}\n\t\telse p->LTag = 0;//标记p->left指向左子树\n\n\t\tif (!prev->right) {\n\t\t\tprev->RTag = 1;//标记p->right为右线索\n\t\t\tprev->right = p;//指向后继\n\t\t}\n\t\telse prev->RTag = 0;//标记p->right指向右子树\n\n\t\tprev = p;\n\n\t\tInThreading(p->right, prev);\n\t}\n}\n\n//中序遍历二叉树T，并将线索化，Thrt指向头节点（线索二叉树的头节点）\nvoid InOrderThreading(BTNode*& Thrt, BTNode* root) {\n\n\tThrt = new BTNode;//建立头节点\n\tThrt->LTag = 0;//头节点有左孩子，若树非空，左孩子为树根。若树空，左孩子指向其自己。\n\tThrt->RTag = 1;//头节点右孩子指向序列最后一个节点\n\tThrt->right = Thrt;//右孩子初始化指向自己\n\n\tif (!root)Thrt->left = Thrt;\n\telse {\n\t\tThrt->left = root;\n\t\tBTNode* prev = Thrt;//前趋节点，初始化指向头节点\n\t\tInThreading(root, prev);\n\n\t\tprev->right = Thrt;//递归出来prev指向序列最后一个节点,对最后一个节点序列化\n\t\tprev->RTag = 1;\n\n\t\tThrt->right = prev;\n\t}\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br")])]),n("h4",{attrs:{id:"先序线索二叉树的构建"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#先序线索二叉树的构建"}},[s._v("#")]),s._v(" 先序线索二叉树的构建")]),s._v(" "),n("p",[s._v("还是一样，在修改空指针前我们需要记下当前结点的前驱后继！所以"),n("strong",[s._v("设置一个指针"),n("code",[s._v("pre")]),s._v("v始终指向刚刚访问过的结点，而"),n("code",[s._v("p")]),s._v("指针指向当前结点")]),s._v("，在构造先序线索二叉树前，我们先理解pre指针和p指针时如何记录当前结点和前趋的，这样能更有利于我们理解先二叉树的构建：")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//将以p为根的二叉树线索化\nvoid InThreading(BTNode* p, BTNode*& prev) {\n\t//if (!root)return;//可以写但很多余\n\n\t//prev是全局定义好的变量，用于指向刚刚访问过的结点\n\tif (p) {\n\t\tprev = p;\n\n\t\tInThreading(pleft, prev);\n\t\tInThreading(p->right, prev);\n\t}\n}\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br")])]),n("p",[s._v("可以发现和中序相比就是将"),n("code",[s._v("prev=p")]),s._v("移动的了位置")]),s._v(" "),n("p",[s._v("下面就是修改空指针了，此处有点小修改，因为先序线索二叉树可能需要再访问左右子树前，修改左右指针，这直接影响我们原本遍历二叉树所以我们，先将左指针存储起来，再修改左指针：")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//将以p为根的二叉树线索化\nvoid InThreading(BTNode* p, BTNode*& prev) {\n\t//if (!root)return;//可以写但很多余\n\n\t//prev是全局定义好的变量，用于指向刚刚访问过的结点\n\tif (p) {\n\t\tBTNode* pleft = p->left;//先存储左指针，防止下面修改左指针映像二叉树遍历！\n\n\t\tif (!p->left) {\n\t\t\tp->LTag = 1;//标记p->left为左线索\n\t\t\tp->left = prev;//指向前趋\n\t\t}\n\t\telse p->LTag = 0;//标记p->left指向左子树\n\n\t\tif (!prev->right) {\n\t\t\tprev->RTag = 1;//标记p->right为右线索\n\t\t\tprev->right = p;//指向后继\n\t\t}\n\t\telse prev->RTag = 0;//标记p->right指向右子树\n\n\t\tprev = p;\n\n\t\tInThreading(pleft, prev);\n\t\tInThreading(p->right, prev);\n\t}\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br")])]),n("p",[s._v("和中序一样需要对序列最后一个节点序列化，完整实现如下：")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//将以p为根的二叉树线索化\nvoid InThreading(BTNode* p, BTNode*& prev) {\n\t//if (!root)return;//可以写但很多余\n\n\t//prev是全局定义好的变量，用于指向刚刚访问过的结点\n\tif (p) {\n\t\tBTNode* pleft = p->left;//用于临时存储当前节点的left，以放NULL修改后死循环！\n\n\t\tif (!p->left) {\n\t\t\tp->LTag = 1;//标记p->left为左线索\n\t\t\tp->left = prev;//指向前趋\n\t\t}\n\t\telse p->LTag = 0;//标记p->left指向左子树\n\n\t\tif (!prev->right) {\n\t\t\tprev->RTag = 1;//标记p->right为右线索\n\t\t\tprev->right = p;//指向后继\n\t\t}\n\t\telse prev->RTag = 0;//标记p->right指向右子树\n\n\t\tprev = p;\n\n\t\tInThreading(pleft, prev);\n\t\tInThreading(p->right, prev);\n\t}\n}\n\n//中序遍历二叉树T，并将线索化，Thrt指向头节点（线索二叉树的头节点）\nvoid InOrderThreading(BTNode*& Thrt, BTNode* root) {\n\n\tThrt = new BTNode;//建立头节点\n\tThrt->LTag = 0;//头节点有左孩子，若树非空，左孩子为树根。若树空，左孩子指向其自己。\n\tThrt->RTag = 1;//头节点右孩子指向序列最后一个节点\n\tThrt->right = Thrt;//右孩子初始化指向自己\n\n\tif (!root)Thrt->left = Thrt;\n\telse {\n\t\tThrt->left = root;\n\t\tBTNode* prev = Thrt;//前趋节点，初始化指向头节点\n\t\tInThreading(root, prev);\n\n\t\tprev->right = Thrt;//递归出来prev指向序列最后一个节点,对最后一个节点序列化\n\t\tprev->RTag = 1;\n\n\t\tThrt->right = prev;\n\t}\n}\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br")])]),n("h4",{attrs:{id:"后续线索二叉树的构建"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#后续线索二叉树的构建"}},[s._v("#")]),s._v(" 后续线索二叉树的构建")]),s._v(" "),n("p",[s._v("经过上面两个例子，后续线索二叉树就是将修改空指针和记录位置下移，但不同的是后续序列最后一个节点是不一定要序列化的因此还要判断，再序列化，代码实现")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//将以p为根的二叉树线索化\nvoid InThreading(BTNode* p, BTNode*& prev) {\n\t//if (!root)return;//可以写但很多余\n\n\t//prev是全局定义好的变量，用于指向刚刚访问过的结点\n\tif (p) {\n\n\t\tInThreading(p->left, prev);\n\n\t\tInThreading(p->right, prev);\n\n\t\tif (!p->left) {\n\t\t\tp->LTag = 1;//标记p->left为左线索\n\t\t\tp->left = prev;//指向前趋\n\t\t}\n\t\telse p->LTag = 0;//标记p->left指向左子树\n\n\t\tif (!prev->right) {\n\t\t\tprev->RTag = 1;//标记p->right为右线索\n\t\t\tprev->right = p;//指向后继\n\t\t}\n\t\telse prev->RTag = 0;//标记p->right指向右子树\n\n\t\tprev = p;\n\t}\n}\n\n//中序遍历二叉树T，并将线索化，Thrt指向头节点（线索二叉树的头节点）\nvoid InOrderThreading(BTNode*& Thrt, BTNode* root) {\n\n\tThrt = new BTNode;//建立头节点\n\tThrt->LTag = 0;//头节点有左孩子，若树非空，左孩子为树根。若树空，左孩子指向其自己。\n\tThrt->RTag = 1;//头节点右孩子指向序列最后一个节点\n\tThrt->right = Thrt;//右孩子初始化指向自己\n\n\tif (!root)Thrt->left = Thrt;\n\telse {\n\t\tThrt->left = root;\n\t\tBTNode* prev = Thrt;//前趋节点，初始化指向头节点\n\t\tInThreading(root, prev);\n\n\t\tif (!prev->right) {\n\t\t\tprev->right = Thrt;//递归出来prev指向序列最后一个节点,对最后一个节点序列化\n\t\t\tprev->RTag = 1;\n\t\t}\n        else {\n\t\t\tprev->RTag = 0;\n\t\t}\n\n\t\tThrt->right = prev;\n\t}\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br"),n("span",{staticClass:"line-number"},[s._v("51")]),n("br"),n("span",{staticClass:"line-number"},[s._v("52")]),n("br")])]),n("h3",{attrs:{id:"遍历线索二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#遍历线索二叉树"}},[s._v("#")]),s._v(" 遍历线索二叉树")]),s._v(" "),n("p",[s._v("我们可以直接递归遍历，根据标记判断当前节点是否有左右子树。但我们知道递归遍历二叉树时间复杂度和空间复杂度都是"),n("code",[s._v("O(N)")]),s._v("。但这样丝毫没有发挥线索二叉树的优势，线索二叉树的非递归遍历才是一大亮点！")]),s._v(" "),n("p",[s._v("这里以中序线索二叉树为例，在理解中序线索二叉树非递归遍历前，先要清楚线索二叉树是如何非递归遍历的算法思路：")]),s._v(" "),n("ol",[n("li",[s._v("开始p指针指向A")]),s._v(" "),n("li",[s._v("然后循环找到当前子树最左下角的节点M，并输出！")]),s._v(" "),n("li",[s._v("M通过右索引访问输出N（此时循环结束，N没有右索引）")]),s._v(" "),n("li",[s._v("循环结束就将指针指向该节点的右孩子（也就是新的根节点了）")])]),s._v(" "),n("p",[s._v("下图红线是中序线索二叉树遍历输出过程，每一个红线下方的节点都是当前子树的最左下节点。把握住"),n("strong",[s._v("子树的最左下节是中序遍历的头，右线索是直接后继")]),s._v("。")]),s._v(" "),n("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-2296.oss-cn-shenzhen.aliyuncs.com/image_20221109193911617.png",alt:"image_20221109193911617"}}),s._v(" "),n("p",[s._v("代码实现：")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("void InOrderTraverse(BTNode* T)\n{\n\tBTNode* p = T->left;//线索二叉树头节点的左指针指向实际二叉树的头\n\twhile (p != T)\n\t{\n        //1. 循环找到当前子树的左下角，开始以四字节单元访问！\n\t\twhile (p->LTag == 0)\n\t\t\tp = p->left;\n\t\tcout << p->data;\n        \n        //2. 通过右索引访问直接后继\n\t\twhile (p->RTag == 1 && p->right != T)\n\t\t{\n\t\t\tp = p->right;\n\t\t\tcout << p->data;\n\t\t}\n        \n        //3. 四字节单元访问完，指向右孩子，寻找下一个四字节！\n\t\tp = p->right;\n\t}\n\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br")])]),n("h2",{attrs:{id:"哈夫曼树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#哈夫曼树"}},[s._v("#")]),s._v(" 哈夫曼树")]),s._v(" "),n("h3",{attrs:{id:"基本概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[s._v("#")]),s._v(" 基本概念")]),s._v(" "),n("ul",[n("li",[s._v("结点间路径：从一个结点到另一个结点所经历的结点和分支序列。")]),s._v(" "),n("li",[s._v("结点的路径长度：从根节点到该结点的路径上分支的数目。")]),s._v(" "),n("li",[s._v("结点的权：在实际应用中，人们往往会给树中的每一个结点赋予一个具有某种实际意义的数值，这个数值被称为该结点的权值。")]),s._v(" "),n("li",[s._v("结点的带权路径长度：该结点的路径长度与该结点的权值的乘积。")]),s._v(" "),n("li",[s._v("树的带权路径长度：树中所有叶结点的带权路径长度之和。")])]),s._v(" "),n("img",{staticStyle:{zoom:"50%"},attrs:{src:t(521),alt:"image_20231210201214724"}}),s._v(" "),n("h3",{attrs:{id:"构造哈夫曼树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构造哈夫曼树"}},[s._v("#")]),s._v(" 构造哈夫曼树")]),s._v(" "),n("p",[s._v("给定n个权值分别为w1, w2…wn的结点，构造哈夫曼树的算法描述如下：")]),s._v(" "),n("ol",[n("li",[n("p",[s._v("首先将这n个结点分别视作n棵仅含一个结点的二叉树，构成森林F。")])]),s._v(" "),n("li",[n("p",[s._v("在森林中选取两棵==根结点权值最小的树==作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。")])]),s._v(" "),n("li",[n("p",[s._v("重复选树的过程，知道森林只剩下一棵树")]),s._v(" "),n("p",[s._v("下面是构建哈夫曼树的过程：")]),s._v(" "),n("img",{staticStyle:{zoom:"50%"},attrs:{src:t(522),alt:"image_20231210201512060"}})])]),s._v(" "),n("h3",{attrs:{id:"哈夫曼编码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#哈夫曼编码"}},[s._v("#")]),s._v(" 哈夫曼编码")]),s._v(" "),n("ul",[n("li",[s._v("可变长度编码，对不同字符采用不等长的二进制位表示。")]),s._v(" "),n("li",[s._v("前缀编码：没有一个编码时另一个编码的前缀")])]),s._v(" "),n("p",[n("strong",[s._v("用哈夫曼树得到的编码方案叫哈夫曼编码，并且哈夫曼编码时前缀编码")])]),s._v(" "),n("p",[s._v("具体：对不同的字符赋予权值，就得到了带权的结点，相应构建哈夫曼树。每一个字符对应哈夫曼树的叶子结点，规定查找路径向左为编码1，向右为编码0。该叶子的查找路径就对应了字符的唯一编码。")]),s._v(" "),n("p",[s._v("下面时哈夫曼编码的案例：可以看到同一权值的结点能构造的哈夫曼树不唯一，对应的哈夫曼编码也是不唯一的！")]),s._v(" "),n("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-2296.oss-cn-shenzhen.aliyuncs.com/image_20221116233626629.png",alt:"img"}}),s._v(" "),n("p",[s._v("对使用频率高的字符赋予较高权值，对应哈夫曼树种权值高的结点查找路径更短，相应的编码也更短，从而实现文件压缩！")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("n个权值，组成哈夫曼树节点个数："),n("code",[s._v("2n-1")])])]),s._v(" "),n("li",[n("p",[s._v("哈夫曼结点类")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("#include <iostream>\n\nclass HuffmanNode {\npublic:\n    int weight; // 权值\n    bool flag; // 节点是否加入哈夫曼树的标志\n    HuffmanNode* parent, * lchild, * rchild; // 父节点及左右孩子节点\n\n    // 构造一个空节点\n    HuffmanNode() : weight(0), flag(false), parent(nullptr), lchild(nullptr), rchild(nullptr) {}\n\n    // 构造一个具有权值的节点\n    HuffmanNode(int weight) : weight(weight), flag(false), parent(nullptr), lchild(nullptr), rchild(nullptr) {}\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br")])])]),s._v(" "),n("li",[n("p",[s._v("哈夫曼编码类")])])]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("#include <iostream>\n#include <vector>\n\nclass HuffmanNode {\npublic:\n    int weight; // 权值\n    bool flag; // 节点是否加入哈夫曼树的标志\n    HuffmanNode* parent, * lchild, * rchild; // 父节点及左右孩子节点\n\n    // 构造一个空节点\n    HuffmanNode() : weight(0), flag(false), parent(nullptr), lchild(nullptr), rchild(nullptr) {}\n\n    // 构造一个具有权值的节点\n    HuffmanNode(int weight) : weight(weight), flag(false), parent(nullptr), lchild(nullptr), rchild(nullptr) {}\n};\n\nclass HuffmanTree {\npublic:\n    // 求哈夫曼编码的算法，w存放n个字符的权值(均>0)\n    std::vector<std::vector<int>> huffmanCoding(const std::vector<int>& W) {\n        int n = W.size();  // 字符个数\n        int m = 2*n -1;   //哈夫曼树的节点数\n        // 构造n个具有权值的节点\n        HuffmanNode* HN = new HuffmanNode[m];\n        int i = 0;\n        for (; i<n ; i++) {\n            HN[i] = HuffmanNode(W[i]);\n        }\n        // 创建哈夫曼树\n        for (i = n;  i<m ; i++) {\n            // 在HN[0...1]选择不在哈夫曼树中，且权值weight最小的两个节点min1和min2\n            HuffmanNode* min1 = selectMin(HN,i-1);\n            min1->flag = true;\n            HuffmanNode* min2 = selectMin(HN,i-1);\n            min2->flag = true;\n            // 构造 min1和min2的父节点，并修改父节点的权值\n            HN[i] = new HuffmanNode();\n            min1->parent=HN[i];\n            min2->parent=HN[i];\n            HN[i]->lchild = min1;\n            HN[i]->rchild = min2;\n            HN[i]->weight = min1->weight+min2->weight;\n        }\n        //  从叶子到根 逆向求每个字符的哈夫曼编码\n        std::vector<std::vector<int>> HuffCode(n, std::vector<int>(n)); // 分配n个字符编码存储空间\n        for (int j =0;j<n;j++){\n            // 编码的开始位置，初始化为数组的结尾\n            int start = n-1;\n            // 从叶子节点到根，逆向求编码\n            for(HuffmanNode* c = &HN[j], p=c->parent;p!=nullptr;c=p,p=p->parent){\n                if(p->lchild == c){\n                    HuffCode[j][start--]=0;\n                }else{\n                    HuffCode[j][start--]=1;\n                }\n            }\n            // 编码的开始标志为-1，编码是-1之后的01序列\n            HuffCode[j][start] = -1;\n\n        }\n\n        return HuffCode;\n    }\n\nprivate:\n    // 在HN[0...1]选择不在哈夫曼树中，且权值weight最小的两个节点min1和min2\n    HuffmanNode* selectMin(HuffmanNode* HN, int end) {\n        // 求 不在哈夫曼树中， weight最小值的那个节点\n        HuffmanNode* min = &HN[end];\n        for (int i = 0; i < end; i++) {\n            HuffmanNode* h = &HN[i];\n            // 不在哈夫曼树中， weight最小值\n            if(!h->flag && h->weight<min->weight){\n                min = h;\n            }\n        }\n        return min;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br"),n("span",{staticClass:"line-number"},[s._v("51")]),n("br"),n("span",{staticClass:"line-number"},[s._v("52")]),n("br"),n("span",{staticClass:"line-number"},[s._v("53")]),n("br"),n("span",{staticClass:"line-number"},[s._v("54")]),n("br"),n("span",{staticClass:"line-number"},[s._v("55")]),n("br"),n("span",{staticClass:"line-number"},[s._v("56")]),n("br"),n("span",{staticClass:"line-number"},[s._v("57")]),n("br"),n("span",{staticClass:"line-number"},[s._v("58")]),n("br"),n("span",{staticClass:"line-number"},[s._v("59")]),n("br"),n("span",{staticClass:"line-number"},[s._v("60")]),n("br"),n("span",{staticClass:"line-number"},[s._v("61")]),n("br"),n("span",{staticClass:"line-number"},[s._v("62")]),n("br"),n("span",{staticClass:"line-number"},[s._v("63")]),n("br"),n("span",{staticClass:"line-number"},[s._v("64")]),n("br"),n("span",{staticClass:"line-number"},[s._v("65")]),n("br"),n("span",{staticClass:"line-number"},[s._v("66")]),n("br"),n("span",{staticClass:"line-number"},[s._v("67")]),n("br"),n("span",{staticClass:"line-number"},[s._v("68")]),n("br"),n("span",{staticClass:"line-number"},[s._v("69")]),n("br"),n("span",{staticClass:"line-number"},[s._v("70")]),n("br"),n("span",{staticClass:"line-number"},[s._v("71")]),n("br"),n("span",{staticClass:"line-number"},[s._v("72")]),n("br"),n("span",{staticClass:"line-number"},[s._v("73")]),n("br"),n("span",{staticClass:"line-number"},[s._v("74")]),n("br"),n("span",{staticClass:"line-number"},[s._v("75")]),n("br"),n("span",{staticClass:"line-number"},[s._v("76")]),n("br"),n("span",{staticClass:"line-number"},[s._v("77")]),n("br"),n("span",{staticClass:"line-number"},[s._v("78")]),n("br"),n("span",{staticClass:"line-number"},[s._v("79")]),n("br")])]),n("ul",[n("li",[s._v("哈夫曼编码会用类似如下格式进行存储")])]),s._v(" "),n("p",[s._v("​\t"),n("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://img-blog.csdnimg.cn/2972a158968a449f821fb3ad1bd0a815.png",alt:"img"}})]),s._v(" "),n("ul",[n("li",[n("p",[s._v("测试类")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('#include <iostream>\n#include <vector>\n\nclass HuffmanTree {\npublic:\n    std::vector<std::vector<int>> huffmanCoding(const std::vector<int>& W) {\n        // 实现哈夫曼编码的代码...\n    }\n};\n\nint main() {\n    // 一组权值\n    std::vector<int> W = {6,30,8,9,15,24,4,12};\n    // 创建哈夫曼树\n    HuffmanTree tree;\n    // 求哈夫曼编码\n    std::vector<std::vector<int>> HN = tree.huffmanCoding(W);\n    // 打印编码\n    std::cout << "哈夫曼编码是：\\n";\n    for (size_t i = 0; i < HN.size(); i++) {\n        std::cout << W[i] << " ";\n        for (size_t j = 0; j < HN[i].size(); j++) {\n            if (HN[i][j] == -1) {\n                for (size_t k = j + 1; k < HN[i].size(); k++) {\n                    std::cout << HN[i][k];\n                }\n                break;\n            }\n        }\n        std::cout << "\\n";\n    }\n\n    return 0;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br")])])])]),s._v(" "),n("h2",{attrs:{id:"并查集"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#并查集"}},[s._v("#")]),s._v(" 并查集")]),s._v(" "),n("h3",{attrs:{id:"定义-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#定义-2"}},[s._v("#")]),s._v(" 定义")]),s._v(" "),n("p",[s._v("并查集是一种用来管理元素分组情况的数据结构。")]),s._v(" "),n("p",[n("strong",[s._v("可以高效进行如下操作")])]),s._v(" "),n("ul",[n("li",[n("p",[s._v("查询元素a和元素b 是否属于同一组。")])]),s._v(" "),n("li",[n("p",[s._v("合并元素a和元素b 所在的组")]),s._v(" "),n("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://img-blog.csdnimg.cn/20210111114543316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzg4NzQy,size_16,color_FFFFFF,t_70#pic_center",alt:"分组和对应的例子"}})])]),s._v(" "),n("h3",{attrs:{id:"并查集的结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#并查集的结构"}},[s._v("#")]),s._v(" 并查集的结构")]),s._v(" "),n("p",[s._v("并查集是"),n("code",[s._v("树形结构")]),s._v("。不过，不是二叉树。")]),s._v(" "),n("p",[s._v("每个元素对应一个节点，每个组对应一颗树。")]),s._v(" "),n("p",[n("em",[s._v("在并查集中，哪个节点是哪个节点的父亲以及树的形状等信息不用关注，整体是树形结构才最重要")])]),s._v(" "),n("h4",{attrs:{id:"_1-初始化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-初始化"}},[s._v("#")]),s._v(" 1. 初始化")]),s._v(" "),n("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://img-blog.csdnimg.cn/20210111114957669.png#pic_center",alt:"初始化"}}),s._v(" "),n("h4",{attrs:{id:"_2-合并"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-合并"}},[s._v("#")]),s._v(" 2. 合并")]),s._v(" "),n("p",[s._v("和下面图一样，从一个组的根向另一个组的跟连边，将两棵树变成 一颗树，也就是两个组变成一个组")]),s._v(" "),n("img",{staticStyle:{zoom:"33%"},attrs:{src:t(523),alt:"image_20231210203640735"}}),s._v(" "),n("h4",{attrs:{id:"_3-查询"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-查询"}},[s._v("#")]),s._v(" 3. 查询")]),s._v(" "),n("p",[s._v("为了查询两个节点是否同一组，只要沿着树向上走，查询"),n("code",[s._v("根节点是否相同")]),s._v("，根节点相同时同一组，否则不同组。如上图中 （2）（5）的根是 （1），而（7）的根是（6） 所以（2）和（5）是同一组，但是（2）和（7）不是同一组。")]),s._v(" "),n("p",[s._v("代码实现")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("#include <vector>\n\nclass UnionFind {\npublic:\n    // 构造函数\n    UnionFind(std::vector<int>& nums) {\n        par.resize(nums.size());\n        rank.resize(nums.size());\n        \n        for (size_t i = 0; i < nums.size(); i++) {\n            par[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    // 查询树的根\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return find(par[x]);\n        }\n    }\n\n    // 查询x和y是否为同一集合\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    // 合并x和y所属集合\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) {\n            return;\n        }\n\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n        } else {\n            par[y] = x;\n            if (rank[x] == rank[y]) {\n                rank[x]++;\n            }\n        }\n    }\n\nprivate:\n    std::vector<int> par;  // 父节点数组\n    std::vector<int> rank; // 节点的秩\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br"),n("span",{staticClass:"line-number"},[s._v("51")]),n("br"),n("span",{staticClass:"line-number"},[s._v("52")]),n("br")])])])}),[],!1,null,null,null);n.default=e.exports}}]);
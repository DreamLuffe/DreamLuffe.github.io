(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{483:function(s,t,a){s.exports=a.p+"assets/img/image_20231217181052404.44519d2a.png"},484:function(s,t,a){s.exports=a.p+"assets/img/image_20231217181151403.8d204803.png"},485:function(s,t,a){s.exports=a.p+"assets/img/image_20231217185420958.c2b7d5e6.png"},486:function(s,t,a){s.exports=a.p+"assets/img/image_20231217185449130.3b6ebf5e.png"},487:function(s,t,a){s.exports=a.p+"assets/img/image_20231217185745436.127ad28e.png"},488:function(s,t,a){s.exports=a.p+"assets/img/image_20231217185921003.76de43d8.png"},489:function(s,t,a){s.exports=a.p+"assets/img/image_20231217190018194.14d198a2.png"},490:function(s,t,a){s.exports=a.p+"assets/img/image_20231217190550930.768b628e.png"},491:function(s,t,a){s.exports=a.p+"assets/img/image_20231217191050813.2291436c.png"},492:function(s,t,a){s.exports=a.p+"assets/img/image_20231217191227332.5c303cd7.png"},493:function(s,t,a){s.exports=a.p+"assets/img/image_20231217191535016.4b294ac9.png"},494:function(s,t,a){s.exports=a.p+"assets/img/image_20231217191751980.30abd209.png"},495:function(s,t,a){s.exports=a.p+"assets/img/image_20231217191939243.100343cc.png"},496:function(s,t,a){s.exports=a.p+"assets/img/image_20231217194501260.17334cc3.png"},641:function(s,t,a){"use strict";a.r(t);var n=a(2),i=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"六、图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、图"}},[s._v("#")]),s._v(" 六、图")]),s._v(" "),t("h2",{attrs:{id:"图的基本概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图的基本概念"}},[s._v("#")]),s._v(" 图的基本概念")]),s._v(" "),t("h3",{attrs:{id:"图的定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图的定义"}},[s._v("#")]),s._v(" 图的定义")]),s._v(" "),t("p",[s._v("图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。")]),s._v(" "),t("h3",{attrs:{id:"图的相关术语"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图的相关术语"}},[s._v("#")]),s._v(" 图的相关术语")]),s._v(" "),t("h5",{attrs:{id:"无向边"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无向边"}},[s._v("#")]),s._v(" 无向边")]),s._v(" "),t("p",[s._v("若顶点vi到vj之间没有方向,则称这条边为无向边，有无序偶对(vi,vj)来表示。")]),s._v(" "),t("h5",{attrs:{id:"无向图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无向图"}},[s._v("#")]),s._v(" 无向图")]),s._v(" "),t("p",[s._v("如果图中任意两个顶点之间的边都是无向边，则称该图为无向图")]),s._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:a(483),alt:"image_20231217181052404"}}),s._v(" "),t("h5",{attrs:{id:"有向边"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有向边"}},[s._v("#")]),s._v(" 有向边")]),s._v(" "),t("p",[s._v("若从顶点vi到vj的边有方向为有向边，也称为弧,用 有序偶< vi, vj> 来表示，vi称为弧尾，vj称为弧头。")]),s._v(" "),t("h5",{attrs:{id:"有向图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有向图"}},[s._v("#")]),s._v(" 有向图")]),s._v(" "),t("p",[s._v("如果图中任意两个顶点之间的边都是有向边，则称该图为有向图。")]),s._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:a(484),alt:"image_20231217181151403"}}),s._v(" "),t("h5",{attrs:{id:"简单图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单图"}},[s._v("#")]),s._v(" 简单图")]),s._v(" "),t("p",[s._v("在图中,如果不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。")]),s._v(" "),t("h5",{attrs:{id:"无向完全图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无向完全图"}},[s._v("#")]),s._v(" 无向完全图")]),s._v(" "),t("p",[s._v("在无向图，如果任意两个顶点之间都有存在边，则称该图为无向完全图。")]),s._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:a(485),alt:"image_20231217185420958"}}),s._v(" "),t("h5",{attrs:{id:"有向完全图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有向完全图"}},[s._v("#")]),s._v(" 有向完全图")]),s._v(" "),t("p",[s._v("在有向图中，如果任意两个顶点之间都存在互为相反的弧，则称该图为有向完全图")]),s._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:a(486),alt:"image_20231217185449130"}}),s._v(" "),t("p",[s._v("有很少的边或弧的图称为稀疏图，反之称为稠密图\n权:有些图的边或者弧具有与他相关的数字，这个相关的数称为权")]),s._v(" "),t("h5",{attrs:{id:"网"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网"}},[s._v("#")]),s._v(" 网")]),s._v(" "),t("p",[s._v("这种边带权值的图叫网")]),s._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:a(487),alt:"image_20231217185745436"}}),s._v(" "),t("h3",{attrs:{id:"图的存储结构和基本运算算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图的存储结构和基本运算算法"}},[s._v("#")]),s._v(" 图的存储结构和基本运算算法")]),s._v(" "),t("h4",{attrs:{id:"图的存储结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图的存储结构"}},[s._v("#")]),s._v(" 图的存储结构")]),s._v(" "),t("p",[t("strong",[s._v("邻接矩阵")])]),s._v(" "),t("p",[s._v("邻接矩阵用两个数组保存数据。一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息。")]),s._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:a(488),alt:"image_20231217185921003"}}),s._v(" "),t("p",[t("strong",[s._v("邻接矩阵的表示")])]),s._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:a(489),alt:"image_20231217190018194"}}),s._v(" "),t("p",[t("strong",[s._v("其他存储结构")])]),s._v(" "),t("p",[t("strong",[s._v("邻接表")]),s._v("：是由每个顶点以及它的相邻顶点组成的")]),s._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:a(490),alt:"image_20231217190550930"}}),s._v(" "),t("p",[s._v("如上图：图中最左侧红色的表示各个顶点，它们对应的那一行存储着与它相关联的顶点")]),s._v(" "),t("ul",[t("li",[t("code",[s._v("顶点A")]),s._v(" 与 顶点B 、顶点C 、顶点E 相关联")]),s._v(" "),t("li",[t("code",[s._v("顶点B")]),s._v(" 与 顶点A 相关联")]),s._v(" "),t("li",[t("code",[s._v("顶点C")]),s._v(" 与 顶点A 、顶点D 、顶点E 相关联")]),s._v(" "),t("li",[t("code",[s._v("顶点D")]),s._v(" 与 顶点C 相关联")]),s._v(" "),t("li",[t("code",[s._v("顶点E")]),s._v(" 与 顶点A 、顶点C 相关联")])]),s._v(" "),t("p",[t("strong",[s._v("十字链表")]),s._v("：用于存储有向图；")]),s._v(" "),t("p",[t("strong",[s._v("邻接多重表")]),s._v("：用于存储无向图")]),s._v(" "),t("h4",{attrs:{id:"图的算法实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图的算法实现"}},[s._v("#")]),s._v(" 图的算法实现")]),s._v(" "),t("p",[t("strong",[s._v("图的结构体创建")])]),s._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("typedef struct {\n\tVexType vexs[MAXVEXNUM];//点的集合\n\tArcCell arcs[MAXVEXNUM][MAXVEXNUM];//边的集合\n\tint vexNum, arcNum;\n}MyGraph;\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("p",[t("strong",[s._v("图的创建")])]),s._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("void CreateDGraphFromConsole(MyGraph &G, int vexNum, int arcNum){\nG.vexNum=vexNum;\nG.arcNum=arcNum;\nfor(int i=0;i<G.vexNum;i++){\n\tcin>>G.vexs[i];\n}\nfor(int i=0;i<G.vexNum;i++){\n\tfor(int j=0;j<G.vexNum;j++){\n\t\tG.arcs[i][j]=0;\n\t}\n}\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br")])]),t("p",[t("strong",[s._v("图的删除")])]),s._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('void DispGraph(MyGraph& G){\n\tfor(int i=0;i<G.vexNum;i++){\n\t\tcout<<G.vexs[i];\n\t\tfor(int j=0;j<G.vexNum;j++){\n\t\tcout<<" "<<G.arcs[i][j];\n\t}\n\t\tcout<<endl;\n\t}\n}\n')])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br")])]),t("h3",{attrs:{id:"图的遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图的遍历"}},[s._v("#")]),s._v(" 图的遍历")]),s._v(" "),t("p",[t("strong",[s._v("BFS算法")])]),s._v(" "),t("p",[s._v("BFS，即图的广度优先搜索遍历，它类似于图的层次遍历，它的基本思想是：首先访问起始顶点v，然后选取v的所有邻接点进行访问，再依次对v的邻接点相邻接的所有点进行访问，以此类推，直到所有顶点都被访问过为止。")]),s._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:a(491),alt:"image_20231217191050813"}}),s._v(" "),t("p",[s._v("BFS广度优先遍历代码：")]),s._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("bool visited[MAX_VERTEX_NUM];   //访问标记数组 访问置为true\n \nvoid BFSTraverse(Graph G){\n\tfor(int i = 0; i<G.vexnum; i++)\n\t   visited[i] = false;  //初始化标记数组\n\tInitQueue Q;\n\tfor(i = 0; i<G.vexnum; ++i)  //从头开始遍历 \n\t   if(!visited[i])        //保证每一个结点都进行BFS \n\t     BFS(G,i);      \n} \n \nvoid BFS(Graph G, int V){\n\tvisit(v);  //访问初始的顶点\n\tvisited[v] = true; //标记上面防止二次访问\n\tEnQueue(Q, v);  //BFS需要利用队列，类似于二叉树的层次遍历\n\twhile(!IsEmpty(Q)){ \n\t\tDeQueue(Q, v); //出队后下一步就是寻找v所有的连接结点\n\t\tfor(int w = FirstNeighbor(G, v) ; w >= 0; w = NextNeighbor(G, v))\n\t\t   if(!visit[w]){ //如果结点未被访问过 \n\t\t   \tvisit(w);\n\t\t   \tvisited[w] = true; //标记 \n\t\t   \tEnQueue(Q, w);  //进队 \n\t\t   } \n\t} \n} \n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br")])]),t("p",[s._v("BFS求解单源最短路径问题------------非带权图")]),s._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("void BFS_MIN_Distance(Graph G, int u){\n\t//d[i]表示从u到i结点的最短路径\n\tfor(int i = 0; i < G.vexnum; ++i)\n\t   d[i] = 0xffffffff; //最大值\n\tvisited[u] = true; d[u] = 0;\n\tEnQueue(Q, u);\n\twhile(!IsEmpty(Q)){ \n\tDeQueue(Q, u); //出队后下一步就是寻找v所有的连接结点\n\t\tfor(int w = FirstNeighbor(G, u) ; w >= 0; w = NextNeighbor(G, u))\n\t\t   if(!visit[w]){ //如果结点未被访问过 \n\t\t   \tvisited[w] = true; //标记 \n\t\t   \td[w] = d[u] + 1; //路径长度加一 \n\t\t   \tEnQueue(Q, w);  //进队 \n\t\t   } \n\t} \n} \n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br")])]),t("p",[s._v("深度优先遍历\n类似于树的先序遍历。")]),s._v(" "),t("p",[s._v("基本思想：先访问初始顶点v，然后从v出发访问与v紧接且未被访问的任意顶点w1然后无限套娃访问w1的紧接为被访问的顶点，当不能在往下继续访问时，依次退回最近被访问的顶点，若这个顶点还有未被访问的顶点，则从该顶点重蹈覆辙\n性能分析：\n空间复杂度：O(V) 因为递归算法需要用到一个递归工作栈\n时间复杂度:邻接矩阵：O(v*v)  邻接表:O(V + E)")]),s._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("bool visited[MAX_VERTEX_NUM];   //访问标记数组 访问置为true\n \nvoid DFSTraverse(Graph G){\n\tfor(int i = 0; i<G.vexnum; i++)\n\t   visited[i] = false;  //初始化标记数组\n\tfor(i = 0; i<G.vexnum; ++i)  //从头开始遍历 \n\t   if(!visited[i])        //保证每一个结点都进行DFS \n\t     DFS(G,i);    \n} \n \nvoid DFS(Graph G, int v){\n\tvisit(v);\n\tvisit[v] = true;\n\tfor(int w = FirstNeighbor(G,v); w >= 0; w = NextNeighbor(G,v,w)){\n\t\tif(!visited(w)){\n\t\t\tDFS(G, w); //递归每次遍历结点的第一个 \n\t\t}\n\t}\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br")])]),t("p",[t("strong",[s._v("DFS算法")])]),s._v(" "),t("p",[s._v("深度优先搜索（Depth First Search）一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。属于盲目搜索,最糟糕的情况算法时间复杂度为O(!n)。\n"),t("img",{staticStyle:{zoom:"50%"},attrs:{src:a(492),alt:"image_20231217191227332"}})]),s._v(" "),t("p",[s._v("DFS采用非递归遍历 ------图采用邻接表形式")]),s._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("//用栈来模拟了一个递归工作栈 \nvoid DFS_Non_RC(Graph G, int v){\n\tint w;\n\tInitStack(S); // 初始化栈\n\tPush(S,v);\n\tvisited[v] = true;\n\twhile(!IsEmpty(S)){\n\t\tk = Pop(S);  //每次出栈都是栈顶 \n\t\tvisit(k);\n\t\tfor(int w = FirstNeighbor(G,k); w >= 0; w = NextNeighbor(G,k,w)){\n\t\t\tif(!visited[w])  //层次遍历的同时，未经过栈的进栈 \n\t\t\t  Push(S,w);\n\t\t\tvisited[w] = true;\n\t\t}\n\t} \n} \n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br")])]),t("h2",{attrs:{id:"生成最小树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生成最小树"}},[s._v("#")]),s._v(" 生成最小树")]),s._v(" "),t("h3",{attrs:{id:"生成树的概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生成树的概念"}},[s._v("#")]),s._v(" 生成树的概念")]),s._v(" "),t("p",[s._v("一个连通图的生成树是一个极小连通子图，它含有图中全部顶点，但只有构成一棵树的(n-1)条边。如果在一棵生成树上添加一条边，必定构成一个环。一棵有n个顶点的生成树(连通无回路图)有且仅有(n-1)条边，如果一个图有n个顶点和小于(n-1)条边，则是非连通图。如果它多于(n-1)条边，则一定有回路。但是，有(n-1)条边的图不一定都是生成树。")]),s._v(" "),t("h3",{attrs:{id:"最小生成树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最小生成树"}},[s._v("#")]),s._v(" 最小生成树")]),s._v(" "),t("p",[s._v("图的所有生成树中具有边上的权值之和最小的树。按照生成树的定义，n个顶点的连通图的生成树有n个顶点、n-1条边。")]),s._v(" "),t("h3",{attrs:{id:"构造最小生成树的准则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造最小生成树的准则"}},[s._v("#")]),s._v(" 构造最小生成树的准则")]),s._v(" "),t("p",[s._v("（1）必须只使用该图中的边来构造最小生成树；\n（2）必须使用且仅使用n-1条边来连接图中的n个顶点；\n（3）不能使用产生回路的边。")]),s._v(" "),t("h4",{attrs:{id:"普里姆-prim-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#普里姆-prim-算法"}},[s._v("#")]),s._v(" 普里姆（Prim）算法")]),s._v(" "),t("p",[s._v("以一个顶点U={u0}为初态，不断寻找与U中顶点相邻且代价最小的边的另一个顶点，扩充U集合直到U=V时为止。生成过程可以如图所示，a是原图，之后是生成过程。")]),s._v(" "),t("img",{staticStyle:{zoom:"33%"},attrs:{src:a(493),alt:"image_20231217191535016"}}),s._v(" "),t("img",{staticStyle:{zoom:"33%"},attrs:{src:a(494),alt:"image_20231217191751980"}}),s._v(" "),t("h4",{attrs:{id:"克鲁斯卡尔-kruskal-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#克鲁斯卡尔-kruskal-算法"}},[s._v("#")]),s._v(" 克鲁斯卡尔(Kruskal)算法")]),s._v(" "),t("p",[s._v("克鲁斯卡尔求最小生成树的思想是假设初始状态为只有n个顶点而无边的非连通图T={V,{}}，图中每个顶点自成一个分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边，直到T中所有顶点都在同一连通分量上为止。")]),s._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:a(495),alt:"image_20231217191939243"}}),s._v(" "),t("h2",{attrs:{id:"图的最短路径问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图的最短路径问题"}},[s._v("#")]),s._v(" 图的最短路径问题")]),s._v(" "),t("h3",{attrs:{id:"最短路径的问题阐述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最短路径的问题阐述"}},[s._v("#")]),s._v(" 最短路径的问题阐述")]),s._v(" "),t("p",[s._v("最短路径问题：如果从有向图中某一顶点(称为源点)到达另一顶点(称为终点)的路径可能不止一条，如何找到一条路径使得沿此路径上各边上的权值总和达到最小。")]),s._v(" "),t("h3",{attrs:{id:"单源最短路径问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单源最短路径问题"}},[s._v("#")]),s._v(" 单源最短路径问题")]),s._v(" "),t("p",[s._v("给定一个带权有向图 D 与源点 v ，求从v 到 D 中其它顶点的最短路径。限定各边上的权值大于0。")]),s._v(" "),t("h3",{attrs:{id:"迪杰斯特拉-dijkstra-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#迪杰斯特拉-dijkstra-算法"}},[s._v("#")]),s._v(" 迪杰斯特拉(Dijkstra)算法")]),s._v(" "),t("p",[s._v("提出了一个按路径长度递增的次序产生最短路径的算法。首先求出长度最短的一条最短路径，再参照它求出长度次短的一条最短路径，依次类推，直到从顶点 v 到其它各顶点的最短路径全部求出为止。")]),s._v(" "),t("h3",{attrs:{id:"弗洛伊德算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#弗洛伊德算法"}},[s._v("#")]),s._v(" 弗洛伊德算法")]),s._v(" "),t("p",[s._v("弗洛伊德算法仍从图的带权邻接矩阵Edge[i][j]出发，其基本思想是：假设求顶点vi到vj的最短路径。如果从vi到vj有弧（无向图称为边），则从vi到vj存在一条长度为Edge[i][j]的路径，该路径不一定是最短路径，尚需n次试探。首先考虑路径（vi ，v0 ，vj）是否存在（即判别弧(vi ，v0 )和弧(v0 ，vj)是否存在）。如果存在,则比较(vi ，vj)和(vi ，v0 ，vj)的路径长度取长度较短者为从vi到vj的中间定点序号不大于0的最短路径。假如在路径上再增加一个顶点v1，也就是说，如果（vi ，…，v1）和（v1，…，vj）分别是当前找到的中间顶点的序号不大于0的最短路径,那么（vi ，…，v1，…，vj）就有可能是从vi到vj的中间顶点的序号不大于1的最短路径。将它和已经得到的从vi到vj中间顶点序号不大于0的最短路径相比较，从中选出中间顶点的序号不大于1的最短路径之后，再增加一个顶点v2，继续进行试探。依次类推，若vi ，…，vk）和（vk，…，vj）分别是从vi到vk和从vk到vj中间顶点的序号不大于k-1的最短路径,则将（vi ，…，vk，…，vj）和已经找到的从vi到vj且中间顶点序号不大于k-1的最短路径相比较，其长度较短者是从vi到vj的中间顶点序号不大于k的最短路径。这样，经过n次比较后，最后求得的必是从vi到vj的最短路径。按此方法，可以同时求得各对顶点间的最短路径。")]),s._v(" "),t("h2",{attrs:{id:"aoe网与关键路径"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aoe网与关键路径"}},[s._v("#")]),s._v(" AOE网与关键路径")]),s._v(" "),t("h3",{attrs:{id:"aoe的概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aoe的概念"}},[s._v("#")]),s._v(" AOE的概念")]),s._v(" "),t("p",[s._v("AOE网是一个带权的有向无环图。其中用顶点表示事件，弧表示活动，权值表示两个活动持续的时间。AOE网是以边表示活动的网。\n  AOV网描述了活动之间的优先关系，可以认为是一个定性的研究，但是有时还需要定量地研究工程的进度，如整个工程的最短完成时间、各个子工程影响整个工程的程度、每个子工程的最短完成时间和最长完成时间。在AOE网中，通过研究事件和活动之间的关系，可以确定整个工程的最短完成时间，明确活动之间的相互影响，确保整个工程的顺利进行。\n  在用AOE网表示一个工程计划时，用顶点表示各个事件，弧表示子工程的活动，权值表示子工程的活动需要的时间。在顶点表示事件发生之后，从该顶点出发的有向弧所表示的活动才能开始。在进入某个顶点的有向弧所表示的活动完成之后，该顶点表示的事件才能发生。\n  对一个工程来说，只有一个开始状态和一个结束状态。因此在AOE网中，只有一个入度为零的点表示工程的开始，称为源点；只有一个出度为零的点表示工程的结束，称为汇点。")]),s._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:a(496),alt:"image_20231217194501260"}}),s._v(" "),t("h3",{attrs:{id:"关键路径的概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关键路径的概念"}},[s._v("#")]),s._v(" 关键路径的概念")]),s._v(" "),t("blockquote",[t("p",[s._v("关键路径是指在AOE网中从源点到汇点路径最长的路径。这里的路径长度是指路径上各个活动持续时间之和。在AOE网中，有些活动是可以并行执行的，关键路径其实就是完成工程的最短时间所经过的路径。关键路径上的活动称为关键活动。")])]),s._v(" "),t("p",[s._v("求AOE网的关键路径的步骤：\n1、对AOE网中的顶点进行拓扑排序，如果得到的拓扑序列顶点个数小于网中顶点数，则说明网中有环存在，不能求关键路径，终止算法。否则，从源点v0开始，求出各个顶点的最早发生时间ve(i)。\n2、从汇点vn出发vl(n-1)=ve(n-1)，按照逆拓扑序列求其他顶点的最晚发生时间vl(i)。\n3、由各顶点的最早发生时间ve(i)和最晚发生时间vl(i)，求出每个活动ai的最早开始时间e(i)和最晚开始时间l(i)。\n4、找出所有满足条件e(i)=l(i)的活动ai，ai即是关键活动。")])])}),[],!1,null,null,null);t.default=i.exports}}]);